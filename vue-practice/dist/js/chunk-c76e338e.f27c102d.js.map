{"version":3,"sources":["webpack:///src/views/NavigationGuard.vue","webpack:///./src/views/NavigationGuard.vue?49e7","webpack:///./src/views/NavigationGuard.vue?f061","webpack:///./src/views/NavigationGuard.vue"],"names":["render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","staticClass","_v","component"],"mappings":"+HA0BA,QACE,KAAF,WACE,iBAFF,SAEA,OAEI,QAAJ,wCACI,GAAJ,YACM,QAAN,iCAGE,kBATF,SASA,OAEI,QAAJ,yCACI,KAEF,iBAdF,SAcA,OAEI,QAAJ,wCACA,uBACM,Q,iEC5CN,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAsBH,EAAII,MAAMC,GAAO,OAAOL,EAAIM,GAAG,IACnGC,EAAkB,CAAC,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBE,EAAGL,EAAII,MAAMC,IAAIH,EAAG,OAAOG,EAAG,MAAM,CAACA,EAAG,KAAK,CAACG,YAAY,SAAS,CAACR,EAAIS,GAAG,cAAcJ,EAAG,MAAM,CAACL,EAAIS,GAAG,mpB,YCDgK,S,YCOrVC,EAAY,eACd,EACAX,EACAQ,GACA,EACA,KACA,KACA,MAIa,aAAAG,E","file":"js/chunk-c76e338e.f27c102d.js","sourcesContent":["<template>\n    <div>\n        <h1 class=\"title\">Vue 导航守卫</h1>\n<pre>\n1. 导航守卫：\n    1).路由跳转之前 beforeEach((to,frome,next)=>{next()})\n    2).路由跳转成功 beforeResolve((to,frome,next)=>{})\n    3).路由跳转之后 afterEach((to,frome)=>{})\n    4).路由的配置里还可以设置一个属性方法 beforeEnter:(to,from,next)=>{next()}\n    5).也可以将这些钩子函数定义于组件中，分别是：\n       beforeRouteEnter 这个钩子函数里，在next()之前是拿不到实例数据的\n       只有在next中接受的回调来获取实例数据\n       beforeRouteUpdate 不同的路由显示同一个组件的时候就会被触发，\n       比如说路由里有传ID参数，每次获取的数据不同，但是使用的是用一个组件\n       beforeRouteLeave\n\n       如果在相同组件显示的不同路由下，使用mounted，就会发现这里mounted只是第一触发了，第二次就没有被触发，\n       也就是说，我们需要通过eforeRouteUpdate来执行一些操作，或者使用watch\n       \n\n2. 异步组件，也就是按需加载组件\ncomponent:()=>import('../views/ComponentRender.vue')\n</pre>\n    </div>\n</template>\n<script>\nexport default {\n    name:'NavGuard',\n    beforeRouteEnter (to, from, next) {\n        // ...\n        console.log('------->>>>>>beforeRouteEnter')\n        next(vm=>{\n            console.log('------->next中的回调',vm)\n        })\n    },\n    beforeRouteUpdate (to, from, next) {\n        // ...\n        console.log('------->>>>>>beforeRouteUpdate')\n        next()\n    },\n    beforeRouteLeave (to, from, next) {\n        // ...可以做一些提示，比如填了一个表单，当用户跳转的时候可以询问是否要保存数据\n        console.log('------->>>>>>beforeRouteLeave')\n        if(global.confirm('你确定要离开吗？')){\n            next()\n        }\n        \n    },\n}\n</script>","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('h1',{staticClass:\"title\"},[_vm._v(\"Vue 导航守卫\")]),_c('pre',[_vm._v(\"1. 导航守卫：\\n    1).路由跳转之前 beforeEach((to,frome,next)=>{next()})\\n    2).路由跳转成功 beforeResolve((to,frome,next)=>{})\\n    3).路由跳转之后 afterEach((to,frome)=>{})\\n    4).路由的配置里还可以设置一个属性方法 beforeEnter:(to,from,next)=>{next()}\\n    5).也可以将这些钩子函数定义于组件中，分别是：\\n       beforeRouteEnter 这个钩子函数里，在next()之前是拿不到实例数据的\\n       只有在next中接受的回调来获取实例数据\\n       beforeRouteUpdate 不同的路由显示同一个组件的时候就会被触发，\\n       比如说路由里有传ID参数，每次获取的数据不同，但是使用的是用一个组件\\n       beforeRouteLeave\\n\\n       如果在相同组件显示的不同路由下，使用mounted，就会发现这里mounted只是第一触发了，第二次就没有被触发，\\n       也就是说，我们需要通过eforeRouteUpdate来执行一些操作，或者使用watch\\n       \\n\\n2. 异步组件，也就是按需加载组件\\ncomponent:()=>import('../views/ComponentRender.vue')\\n\")])])}]\n\nexport { render, staticRenderFns }","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NavigationGuard.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NavigationGuard.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./NavigationGuard.vue?vue&type=template&id=6f9d9683&\"\nimport script from \"./NavigationGuard.vue?vue&type=script&lang=js&\"\nexport * from \"./NavigationGuard.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}