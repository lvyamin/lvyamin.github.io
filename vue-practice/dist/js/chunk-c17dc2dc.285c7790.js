(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-c17dc2dc"],{b9d1:function(n,o,e){"use strict";var t=e("fd25"),p=e.n(t);p.a},bb51:function(n,o,e){"use strict";e.r(o);var t=function(){var n=this,o=n.$createElement,e=n._self._c||o;return e("div",{ref:"home"},[e("h1",{staticClass:"title"},[n._v("实例的各种属性：")]),e("pre",[n._v("  console.log('$data:',app.$data)\n  console.log('$props:',app.$props)\n  console.log('$el:',app.$el)\n  console.log('$options:',app.$options)\n  console.log('$root:',app.$root)\n  console.log('$root===app:',app.$root===app)\n  console.log('$children:',app.$children)\n  console.log('$slots:',app.$slots)\n  console.log('$scopeslots:',app.$scopeSlots)\n  console.log('$refs:',app.$refs)\n  console.log('$isServer:',app.$isServer)\n ")]),e("h1",{staticClass:"title"},[n._v("实例的各种方法：")]),e("pre",[n._v("  const unWatch = app.$watch('test',(newVal,oldVal)=>{\n    console.log(`${newVal}:${oldVal}`)\n  })\n\n  setTimeout(()=>{\n    unWatch()\n  },3000)// watch 事件销毁\n\n  app.$on('testOn',(a,b)=>{\n    console.log(`app.$on:testOn ${a}:${b}`)\n  })\n  app.$once('testOnce',(a,b)=>{\n    console.log(`app.$once:testOnce ${a}:${b}`)\n  })\n  app.$emit('testOn',1,2)\n  // emit 和 on 作用于同一个组件上才生效\n  setInterval(()=>{\n    app.$emit('testOn',3,4)\n  },3000)\n\n  setInterval(()=>{\n    app.$emit('testOnce',0,0)\n  },3000)\n\n  // app.$nextTick(()=>{}) // 将回调延迟到下次DOM更新循环之后执行\n  // 因为vm渲染DOM是异步的，上面方法就可以让其渲染变成同步的\n ")])])},p=[],s={name:"Home",mounted:function(){}},a=s,l=(e("b9d1"),e("2877")),c=Object(l["a"])(a,t,p,!1,null,"e782ea70",null);o["default"]=c.exports},fd25:function(n,o,e){}}]);
//# sourceMappingURL=chunk-c17dc2dc.285c7790.js.map