(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-c76e338e"],{"048f":function(e,n,o){"use strict";(function(e){n["a"]={name:"NavGuard",beforeRouteEnter:function(e,n,o){console.log("-------\x3e>>>>>beforeRouteEnter"),o((function(e){console.log("-------\x3enext中的回调",e)}))},beforeRouteUpdate:function(e,n,o){console.log("-------\x3e>>>>>beforeRouteUpdate"),o()},beforeRouteLeave:function(n,o,t){console.log("-------\x3e>>>>>beforeRouteLeave"),e.confirm("你确定要离开吗？")&&t()}}}).call(this,o("c8ba"))},"3f7f":function(e,n,o){"use strict";o.r(n);var t=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},r=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",[o("h1",{staticClass:"title"},[e._v("Vue 导航守卫")]),o("pre",[e._v("1. 导航守卫：\n    1).路由跳转之前 beforeEach((to,frome,next)=>{next()})\n    2).路由跳转成功 beforeResolve((to,frome,next)=>{})\n    3).路由跳转之后 afterEach((to,frome)=>{})\n    4).路由的配置里还可以设置一个属性方法 beforeEnter:(to,from,next)=>{next()}\n    5).也可以将这些钩子函数定义于组件中，分别是：\n       beforeRouteEnter 这个钩子函数里，在next()之前是拿不到实例数据的\n       只有在next中接受的回调来获取实例数据\n       beforeRouteUpdate 不同的路由显示同一个组件的时候就会被触发，\n       比如说路由里有传ID参数，每次获取的数据不同，但是使用的是用一个组件\n       beforeRouteLeave\n\n       如果在相同组件显示的不同路由下，使用mounted，就会发现这里mounted只是第一触发了，第二次就没有被触发，\n       也就是说，我们需要通过eforeRouteUpdate来执行一些操作，或者使用watch\n       \n\n2. 异步组件，也就是按需加载组件\ncomponent:()=>import('../views/ComponentRender.vue')\n")])])}],f=o("048f"),u=f["a"],c=o("2877"),a=Object(c["a"])(u,t,r,!1,null,null,null);n["default"]=a.exports}}]);
//# sourceMappingURL=chunk-c76e338e.f27c102d.js.map