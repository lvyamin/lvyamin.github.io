(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-832d6c0e"],{2311:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("pre",[n._v("定义全局组件：Vue.component('componentname',component)\n定义组件可以用首字母大写的驼峰命名法，运用时候就可以用烤串式命名调用\n也可以用components:{} 的方式来引入组件\n当组件不是new vue 实例化出来的，那么data就需要是个方法\n也有技巧可以跨过这样的限制 那就是 const data = {...}\n组件中用到 :\ndata(){\n    return data\n}\n如果想多次使用同一个组件，为了不会让其相互影响，我们如下处理：\n就不要使用\nconst data = {...}\ndata(){\n    return data\n}\n每一个组件有自己独立的data才不会互相影响\nreturn是一个新建的对象，而不是一个全局的对象，这就是为什么需要data是一个方法的原因\n组件内部不应该去主动修改props中的数据，如果要修改，需要在调用组件的地方去修改\n")]),t("component-one",{ref:"comp1",attrs:{handleClick:n.clickMe,propOne:n.prop1}}),t("component-one",{attrs:{active:!0,propOne:n.prop1}})],1)},a=[],c=t("ade3"),r=t("1f38"),p=Object(c["a"])({name:"Components",components:{ComponentOne:r["a"]},mounted:function(){console.log("获取组件实例：",this.$refs.comp1)},data:function(){return{prop1:0}},methods:{clickMe:function(){this.$emit("handleClick")}}},"mounted",(function(){console.log("thisRefs:",this.$refs.comp1)})),u=p,i=t("2877"),s=Object(i["a"])(u,o,a,!1,null,null,null);e["default"]=s.exports},ade3:function(n,e,t){"use strict";function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}t.d(e,"a",(function(){return o}))}}]);
//# sourceMappingURL=chunk-832d6c0e.7fc8e0cf.js.map